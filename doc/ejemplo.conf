# ircd.conf - archivo de configuración para el ircd versión IRCh.
#
# Ultima actualización:  1, Diciembre 2018.
#
# Escrito por Niels <niels@undernet.org>, basado en el archivo example.conf
# original, en el código del servidor y la experiencia de la vida real.
#
# Actualizado y modificado profundamente por by Braden <dbtem@yahoo.com>.
#
# Reescrito por A1kmm(Andrew Miller)<a1kmm@mware.virtualave.net> para
# soportar el nuevo analizador de configuración flex/bison.
#
# Actualizado por Zoltan (Toni Garcia) <toni@tonigarcia.es>
# Traducido por Zoltan (Toni Garcia) <toni@tonigarcia.es>
#
# Agradecimientos y creditos para: Run, Trillian, Cym, Morrissey, Chaos,
#                                  Flynn, Xorath, WildThang, Mmmm, SeKs,
#                                  Ghostwolf y todo el resto de 
#                                  Administradores y Operadores de
#                                  Undernet, y los programadores del ircd
#                                  de Undernet.
#
# Este es un ejemplo del archivo de configuración usado por el ircd de Hispano.
#
# Este documento está basado en un (fiticio) servidor en Europa con una
# conexión a la red de IRC de Hispano. Este es un servidor "leaf", pero
# si todos los otros "hubs" en Europa no están en servicio, puede conectar
# a uno en los E.E.U.U. por sí mismo.
#
# El formato de la configuración consiste en un número de bloques en este
# formato
#  NombreBloque { ajuste = número; ajuste2 = "texto"; ajuste3 = yes; };
# Notése que los comentarios empiezan con un #(almohadilla) va al extremo
# de la línea. Espacios en blanco (espacio, tabulación, retornos de carro)
# son ignorados y se puede utlizar para hacer más legible el archivo de
# la configuración.
#
# Por favor observe que cuando el ircd pone las líneas en práctica, las
# analiza exactamente al sentido contrario que las lees. Utiliza los
# bloques en el orden reverso.
#
# Esto significa que debes comenzar tus bloques "Client" con "fall through",
# "most vanilla one", y al final con el más detallado.
#
# Hay una diferencia entre el "hostname" y el "nombre del servidor" de la
# máquina que el servidor está corriendo. Por ejemplo, el host puede tener
# "83.Red-80-59-255.pooles.rima-tde.net" como FQDN y "plasma.irc-hispano.org"
# como nombre del servidor.
# Una "máscara de servidor" es algo como "*.EU.irc-hispano.org", que es 
# emparejado por "Vigo.ES.EU.irc-hispano.org" pero no por
# "Miami.FL.US.irc-hispano.org".
#
# Por favor NO renombrar el ejemplo.conf a ircd.conf y no espere
# que esto funcione.


# [General]
#
# Primero una información sobre el servidor.
# General {
#         name = "nombreservidor";
#         vhost = "ipv4vhost";
#         vhost = "ipv6vhost";
#         description = "descripcion";
#         numeric = númerodenúmerico;
#         dns vhost = "ipv4vhost";
#         dns vhost = "ipv6vhost";
#         dns server = "direcciónip";
#         dns server = "direcciónip2";
# };
#
# Si esta presente, el campo "vhost" debe contener una dirección válida
# en la notación de 4 números o notación numérica de IPv6 (127.0.0.1 o ::1).
# La dirección DEBE ser la dirección de una interfaz física en el host.
# Esta dirección se utiliza para las conexiones salientes si el bloque
# "Connect{}" no la elimina. Veáse el bloque "Port{}" para la escucha con
# virtual hosting. En caso de duda no pongas nada o usa "*" que tiene el
# mismo significado que no tener vhost.
#
# Puedes especificar un virtualhost de IPv4 y un virtualhost de IPv6,
# para indicar cuál de las direcciones se debe utilizar para las
# conexiones salientes del tipo respectivo. 
#
# Observe que el campo "numeric" tiene que ser único en la red si tu
# servidor esta funcionando, y debe estar entre 0 y 4095, y no se
# actualiza en un rehash.
#
# Las dos líneas DNS le permiten especificar la dirección IP local a
# utilizar para las búsquedas DNS "dns vhost" y una o más direcciones
# de servidor DNS para utilizar. Si el "vhost" es ambiguo por alguna
# razón, puede listar IPV4 y/o IPV6 entre el signo igual y la cadena
# de dirección.
# El vhost DNS predeterminado es para permitir que el sistema operativo
# asigne la dirección, y los servidores DNS predeterminados se leen desde
 /etc/resolv.conf.
# En la mayoría de los casos, no es necesario especificar el dns vhost o
# el servidor dns.
General {
         name = "devel.irc-hispano.org";
         description = "Servidor de Desarrollo de IRC-Hispano";
         numeric = 1;
};

# [Admin]
#
# Esto fija la información que se puede ver con el comando "/ADMIN".
# Se debe poner por lo menos una dirección de Email de contacto del
# administrador.
Admin {
  # En la mayoría se permiten dos líneas de localización ("Location")...
  Location = "Servidor de Desarrollo de IRC-Hispano";
  Location = "Administrador IRC : zoltan";
  Contact = "Email Administrador <toni@tonigarcia.es>";
};

# [Classes]
#
# Todas las conexiones al servidor están asociadas con una cierta "clase
# de conexión", sean entrantes o salientes (iniciadas por el servidor),
# ya sean clientes, servidores.
#
# Class {
#  name = "nombreclase";
#  pingfreq = tiempo;
#  connectfreq = tiempo;
#  maxlinks = número;
#  sendq = tamańo;
#  usermode = "+i";
# };
#
# Para las clases de conexión que se usan en los enlaces de servidor, 
# el "maxlinks" controla cuando las conexiones salientes deben iniciarse
# automáticamente: si el número de conexiones en la clase es menor que el
# valor maxlinks, se puede establecer una conexión saliente (sujeto a las
# restricciones CRule).
# Esto significa que los hubs deberían tener generalmente maxlinks = 0 para
# enlaces de servidor, y los servidores hijos (leafs)  normalmente tendrían
# maxlinks = 1 para su hub(s).
#
# Para las conexiones de cliente entrantes, el "maxlinks" controla cuando se
# deben aceptar nuevos clientes para la clase. Si el maxlinks es 0, siempre
# se permitirán nuevos clientes. De lo contrario, se permitirán nuevos
# clientes si hay menos de clientes maxlinks en la clase, hasta un límite
# de aproximadamente 4.000.000.000.
#
# El campo "connectfreq" se aplica solamente a los servidores, y especifica
# la frecuencia con la cual el servidor intentará hacer el "autoconnect".
# Ajustando a 0 causará que el servidor intentará repetidamente sin pausa
# hasta que la condición especificada en el campo "maxlinks" esté satisfecha.
# Esto es una mala idea (Bad Thing(tm)).
# Observe que los tiempos se pueden especificar como número, dando algo
# como este: 1 minutes 20 seconds, or 1*60+20.
#
# Clases de servidores recomendadas:
# Todos los uplinks del servidor si tu no eres un "hub".
Class {
 name = "Servidor";
 pingfreq = 1 minutes 30 seconds;
 connectfreq = 5 minutes;
 maxlinks = 1;
 sendq = 9000000;
};
# Todos los servidores "leaf" si tu eres "hub".
Class {
 name = "ServidorLeaf";
 pingfreq = 1 minutes 30 seconds;
 connectfreq = 5 minutes;
 maxlinks = 0;
 sendq = 9000000;
};

# Client {
#  username = "ident";
#  host = "host";
#  ip = "127.0.0.0/8";
#  password = "contraseña";
#  class = "nombreclase";
#  maxlinks = 3;
# };
#
# Todo en un bloque "Client" es opcional. Si se da una máscara de "username",
# eso será comparado con el "username" del cliente del protocolo IDENT,
# una máscara de nombre de usuario coincide con los clientes para los que
# falló el IDENT.
# Si se da una máscara de "host", el hostname del cliente debe ser resuelto y
# comparado con la máscara. Si se da una máscara de "IP" en CIDR, el cliente
# debe tener una IP dentro de ese rango. Si se da el campo "maxlinks", este
# es el límite de clientes permitidos desde una dirección IP particular.
#
# Toma los siguientes bloques de clase solo como una guía.
Class {
 name = "Local";
 pingfreq = 1 minutes 30 seconds;
 sendq = 160000;
 maxlinks = 100;
 usermode = "+iw";
};
Class {
 name = "Otros";
 pingfreq = 1 minutes 30 seconds;
 sendq = 160000;
 maxlinks = 400;
};
Class {
 name = "Telefonica";
 pingfreq = 1 minutes 30 seconds;
 sendq = 80000;
 maxlinks = 5;
};
Class {
 name = "Opers";
 pingfreq = 1 minutes 30 seconds;
 sendq = 160000;
 maxlinks = 10;

 # Para las clases de conexión previstas para el uso de operadores, puedes
 # especificar los privilegios usados cuando el bloque "Operator" (véase
 # abajo) utiliza esta clase. El privilegio local (aka globally_opered)
 # DEBE estar definido por el bloque de "Class" o de "Operator". Existen
 # los siguientes privilegios:
 #
 # local (o "propagate", con el efecto contrario)
 # whox  (puede utlizar el flag x con /WHO)
 # display (estado de Oper visible en lusers)
 # chan_limit (puede entrar en canales locales cuando esta en
 #                              MAXCHANNELSPERUSER canales)
 # mode_lchan (puede usar /MODE &channel sin tener op en el canal)
 # deop_lchan (no puede ser deopeado o kickeado en canales locales)
 # walk_lchan (puede forzar /JOIN &channel OVERRIDE)
 # show_invis (ve usuarios invisibles (+i) en el /WHO x)
 # show_all_invis (ve usuarios invisibles (+i) en el /WHO x)
 # unlimit_query (muestra más resultados desde /WHO)
 # local_kill (puede expulsar (kill) clientes de este servidor)
 # rehash (puede usar /REHASH)
 # restart (puede usar /RESTART)
 # die (puede usar /DIE)
 # local_jupe (puede usar JUPE en este servidor)
 # set (puede usar /SET)
 # local_gline (puede poner una G-line para solamente este servidor)
 # local_badchan (puede poner una Gchan para solamente este servidor)
 # see_chan (puede ver usuarios en canales secretos (+s) en el /WHO x)
 # list_chan (puede ver canales +s con /LIST S, o modos con /LIST M)
 # wide_gline (puede usar ! para forzar una wide G-line)
 # see_opers (puede ver opers sin el privilegio DISPLAY)
 # local_opmode (puede utilizar OPMODE/CLEARMODE en canales locales)
 # force_local_opmode (puede utilizar OPMODE/CLEARMODE en canales en cuarentena locales)
 # kill (puede expulsar (kill) clientes en otros servidores)
 # gline (puede poner G-lines a otros servidores)
 # jupe_server (puede usar JUPE)
 # opmode (puede usar /OPMODE)
 # badchan (puede poner Gchans a otros servidores)
 # force_opmode (puede utilizar OPMODE/CLEARMODE en canales quarantined globales)
 # apass_opmode (puede utilizar OPMODE/CLEARMODE en canales con +A y +K
 # walk_chan (puede forzar /JOIN #channel OVERRIDE)
 # network (puede utilizar CONNECT/SQUIT en servidores)
 # chanserv (puede poner/quitar modo de usuario +k)
 # hidden_viewer (puede poner/quitar modo de usuario +X)
 # whois_notice (puede poner/quitar modo de usuario +W)
 # hide_idle (puede poner/quitar modo de usuario +I)
 #
 # Para los opers globales (con "propagate = yes" o "local = no"), por
 # defecto es conceder todos los privilegios antes mencionados EXCEPTO apass_opmode.
 # Para los opers locales, por defecto es conceder SOLO los siguientes privilegios:
 #  chan_limit, mode_lchan, show_invis, show_all_invis, local_kill,
 #  rehash, local_gline, local_jupe, local_opmode, whox, display,
 #  force_local_opmode
 # Cualquier privilegio listado en un bloque "Class" prevalece a los por
 # defecto.
 #
 # Si un bloque de Clase con "local = no;" y el nombre "RemoteOpers" existe,
 # controla los privilegios concedidos cuando un servicio UWorld envía un
 # comando OPMODE para convertir un cliente en un oper.

 local = no;
};
# [Client]
#
# Para permitir conectar a los clientes, necesitan la autorización. Esta
# se puede otorgar basandose en una máscara de hosts, una máscara de
# direcciones y/o con una contraseña.
# Con un uso inteligente de las clases y el campo de "maxconnections" en
# los bloques "Client", puedes permitir entrar a un dominio específico,
# pero rechazando el resto de dominios del mismo nivel, como si fuera
# creando una especie de "bloque Kill inverso".  
# Client {
#  host = "user@host";
#  ip = "user@ip";
#  password = "contraseńa";
#  class = "nombreclase";
#  sslfp = "sslfingerprint";
# };
#
# Descripción técnica (para los ejemplos, vea abajo):
# Para cada cliente que conecta, su dirección IP es conocida. Se hace una
# consulta de dns inverso a la IP númerica para obtener el/los(todos)
# hostnames.
# Cada hostname que pertenece a esa IP numérica se compara con el campo 
# "host", y el bloque "Client" se usa cuando cualquiera de ellos encaja;
# el cliente entonces se mostrará con ese hostname en concreto. Si ninguno
# de los hostnames encajan, entonces la IP numérica se compara contra el
# campo "ip", y si esta concuerda entonces el bloque "Client" se usa a pesar
# de todo y el cliente mostrará el primer (principal) hostname si existe;
# si la IP numérica no resuelve, el cliente mostrará la notación decimal de
# la IP númerica.
# Hay un caso especial para los sockets de los dominios UNIX y las
# conexiones del host local (localhost); en este caso el campo "ip"
# se compara con el nombre del servidor (de tal suerte que no se hace
# con ninguna representación de una IP numérica). El nombre del servidor
# es el devuelto en la respuesta del numérico 002, por ejemplo:
# 002 Your host is 2.zolty.net[jolan.ppro], running version ..
# Entonces el "jolan.ppro" es el nombre que usa para comparar.
# Por lo tanto, los sockets de dominio unix, y las conexiones al host
# local (localhost), tendrían que satisfacer este bloque:
# host = "*@jolan.ppro";
#
# Esta es la entrada "fallback". Todo .uk, .nl, y todos los sin resolver
# están en estos dos bloques.
# Usando dos bloques diferentes, las conexiones múltiples desde una sola
# IP son permitidas solamente de los hostnames que tienen resoluciones DNS
# directas e inversas válidas.
Client
{
 class = "Otros";
 ip = "*";
 maxlinks = 2;
};


Client
{
 class = "Otros";
 host = "*";
 maxlinks = 2;
};
# Si no quieres que conecten usuarios sin DNS inverso resuelto a tu
# servidor, no poner ajustes de "ip = ".
#
# Aqui, sólo se dejaría entrar a todos los usuarios espańoles de Telefonica.
Client
{
 host = "*.pooles.rima-tde.net";
 class = "Telefonica";
 maxlinks = 2;
};

Client
{
 host = "*.telefonica-data.net";
 class = "Telefonica";
 maxlinks = 2;
};

Client
{
 host = "*.ttd.es";
 class = "Telefonica";
 maxlinks = 2;
};

# Ahora se listan los dominios .com / .net que se desean permitir...
# Esto es menos trabajoso que hacerlo de la otra manera - poniendo "Klined"
# a cada ISP de los E.E.U.U.
# Deseo que la gente de Holanda con dominio .nl, y no intento ser fresco
# y usar .com...
Client { host = "*.wirehub.net"; class = "Otros"; maxlinks = 2; };
Client { host = "*.planete.net"; class = "Otros"; maxlinks = 2; };
Client { host = "*.ivg.com"; class = "Otros"; maxlinks = 2; };
Client { host = "*.ib.com"; class = "Otros"; maxlinks = 2; };
Client { host = "*.ibm.net"; class = "Otros"; maxlinks = 2; };
Client { host = "*.hydro.com"; class = "Otros"; maxlinks = 2; };
Client { host = "*.nl.net"; class = "Local"; maxlinks = 2; };

# Puedes solicitar un listado más completo, incluyendo la "lista estándar
# de bloques "Kill"" del comité de "Routing"; también le será enviada si
# solicita para un servidor y consigues el aprobado.
#
# Nosotros mismos - esto nos asegura poder entrar, independiente de lo lleno
# que esté el servidor.
Client
{
 host = "*.rima-tde.net";
 ip = "*@80.59.0.0/16";
 class = "Local";
 # Un maxlinks de más de 5 será automáticamente glineado por euworld en Undernet
 maxlinks = 5;
};

# Puedes poner una expresión en el campo "maxlinks", que hará que el
# ircd sólo acepte un cliente cuando el numero total de conexiones a la 
# red desde la misma IP numérica no exceda de ese número.
# El siguiente ejemplo aceptaría al menos una conexión por IP numérica
# desde "*.ono.com" y al menos dos conexiones desde cuentas de acceso a
# internet por modem que tengan "*.dial??.*" como máscara de host:
# Client {
#  host = "*@*.ono.com";
#  maxlinks = "1";
#  class = "Otros";
# };
# Client {
#  host = "dial??.*";
#  maxlinks = "2";
#  class = "Otros";
# };
#
# Si no te preocupa de quien se conecta, esta línea permitirá que se
# conecten todos.
Client {
 host = "*";
 ip = "*";
 class = "Otros";
 maxlinks = 2;
};


# También puedes especificar una huella digital certificado de cliente SSL
# para un bloque "Client" como alternativa, o adición a la contraseña, para
# la autentificación.
# Client {
#  host "*@*";
#  ip = "*@*";
#  class = "Otros";
#  sslfp = "61D0720B27D8AED9C0A7CB788091B0D8D9A94E119D5118E574B70EECD41B3C26";
# };

# [Motd]
#
# Es posible mostrar un MOTD (Message of the Day"), a un cliente que
# conecta dependiendo de su origen.
# Motd {
#  # Nota: el campo "host" también puede ser un nombre de clase.
#  host = "Otros";
#  file = "ruta/al/fichero/del/motd";
# };
#
# Más de un host = "máscara"; la entrada puede estar presente en un
# bloque; esto tiene el mismo efecto que un bloque "Motd" para cada
# entrada del anfitrión, pero hace más fácil actualizar el nombre de
# archivo de los mensajes.
#
# DPATH/net_com.motd contiene un MOTD especial donde se anima a los
# usuarios que registren sus dominios y conseguir su propios bloques
# "Client{}" si están en Europa, o moverse a US.irc-hispano.org si están en
# los E.E.U.U..
Motd {
 host = "*.net";
 file = "net_com.motd";
};
Motd {
 host = "*.com";
 file = "net_com.motd";
};
Motd {
 host = "Telefonica";
 file = "telefonica.motd";
};

# Un MOTD diferente para nosotros, donde precisamos que el "helpdesk"
# mejor no ser molestado con preguntas con respeto al IRC...
Motd {
 host = "*.irc-hispano.org";
 file = "irc-hispano.motd";
};

# [Uworld]
#
# Una de las características más atractivas de Hispano, es "Uworld", un
# programa conectado a la red como servidor. Esto le permite realizar
# cualquier cambio de modo, para que esta manera los opers puedan 
# permitir, por ejemplo, desbloquear un canal que ha sufrido un take-over.
# Sólo hay un pequeńo problema: El protocolo del TimeStamp (TS) hace
# que no sea posible. Por esto, hay una opción de configuración para 
# permitir esos cambios desde cierto servidor.
# Uworld {
#  # El nombre del servidor o la máscara para el que esto se aplica.
#  name = "relnombreservidor";
#  # Los servidores introducidos con "oper" pueden remotamente hacer/deshacer
   # IRCop a clientes.
#  oper = "uworld.example.org";
# };
#
# Puedes tener más de un nombre listado en cada bloque.
#
# Nota: (1) Estas líneas son puestas por cada administrador de un servidor
# en IRC-Dev; (2) Estas líneas debe ser exactamente iguales en cada
# servidor, o los resultados serán impredecibles; (3) Esta es una
# característica útil, no algo que es una responsabilidad y abusado
# regularmente (bien... :-)
# Si estás en IRC-Dev, DEBES tener estas líneas. No puedo tener estrés
# por esto. Si todos los servidores no tienen las mismas lineas, los
# servidores intentarán deshacer los "hack" de cambios de modos que hará
# Uworld. ASEGURATE que todos los servidores tengan EXACTAMENTE los mismos
# bloques "Uworld". 
#
# Si tu servidor arranca en una red más grande, es probable que se te
# asignen uno o dos servidores a los que tu servidor pueda conectar.
# Si estos servidores a su vez se conecta a otros servidores que el tuyo
# (lo que es probable), necesitas definir el servidor al que te conectas
# con permiso como "hub".
# Lea la documentación del bloque "Connect" para más detalles de como se
# hace eso.

Uworld {
 oper = "uworld.irc-hispano.org";
 name = "channels.irc-hispano.org";
 name = "deep.space";
};

# Esto es posible para prohibir (Jupe) nicks.
Jupe {
 nick = "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,{,|,},~,-,_,`";
 nick = "EuWorld,UWorld,UWorld2";
 nick = "login,undernet,protocol,pass,newpass,org";
 nick = "StatServ,NoteServ";
 nick = "ChanSvr,ChanSaver,ChanServ";
 nick = "NickSvr,NickSaver,NickServ";
 nick = "LPT1,LPT2,COM1,COM2,COM3,COM4,AUX";
};

# [Kill]
#
# Mientras funciona tu servidor, es muy probablemente que encontrarás a
# personas o grupos de personas a los que no quieres permitir acceso a tu
# servidor.
#
# Para este propósito, el ircd entiende de "kill blocks". Estos también se
# conocen como "K-lines", en virtud del formato anterior del archivo de
# configuracion.
# Kill
# {
#   host = "user@host";
#   reason = "La razón que verá el usuario";
# };
# Es posible prohibir en base del nombre real (Realname).
# También es posible utilizar un archivo como comentario de la prohibición,
# usando file = "archivo":
# Kill
# {
#   realname = "realnameabanear";
#   file = "ruta/al/archivo/con/la/razon/para/mostrar";
# };
#
#
# La razón por defecto es: "You are banned from this server"
# Notese que los bloques "Kill" son locales al servidor; si se prohibe
# a una persona o un dominio entero de tu servidor, aun pueden entrar 
# al IRC por otro servidor que no tengan "Killed" (aun).
#
# Con un simple comentario, usando comillas:
Kill { host = "*.au"; reason = "Por favor, use un servidor más cercano"; };
Kill { host = "*.edu"; reason = "Por favor, use un servidor más cercano"; };

# También puedes poner un kill basado en el username
Kill { username = "sub7"; realname = "s*7*";  reason = "Estás infectado con un Troyano"; };

# El archivo puede contener, por ejemplo, una razón, un enlace a las normas
# del servidor y una dirección de contacto. Observe la combinación del username
#y el host en el campo "host".
Kill
{
 host = "*luser@unixbox.flooder.co.uk";
 file = "kline/youflooded.txt";
};

# Las lineas "kill" basadas en IP se aplican a todos los hosts, incluso si
# una dirección IP tiene un nombre de host resuelto correctamente.
Kill
{
 host = "192.168.*";
 file = "klines/martians";
};

# El campo "realname" permite prohibir por el nombre real (realname)...
Kill
{
 realname = "*sub7*";
 reason = "Estás infectado con un Troyano";
};

# [Except]
#
# Si deseas dar acceso a las personas que tienen un K-line, puedes
# usar E-lines ("líneas de Excepción") que son excepciones a las
# prohibiciones de acceso de las K-lines o las G-lines. Los campos son
# AND, todas las condiciones para que el usuario salte la K-line o G-line.
#
# Except
# {
#   host = "host/ip/cidr";
#   username = "ident";
#   password = "contraseña";
#   port = 7001;
# };
#

# La máscara ip/host y la máscara username indican las máscaras que los
# usuarios con K-line deben tener que queramos que se unan a la red.
Except
{
  host = "*.orange.es";
  username = "root";
};

# La contraseña, si existe, es lo que los usuarios deberán especificar
# como contraseña del servidor para poder saltar la K-line.
#
Except
{
  host = "*.rima-tde.net";
  password = "plisplas";
};
#
# El puerto, si lo hay, es el puerto a través del cual los usuarios tendrán
# que conectarse para poder saltar la K-line. Debe existir el puerto especificado
# (Bloque Port).
#
Except
{
  host = "192.168.0.15";
  port = 6669;
};


# [Connect]
#
# Es probable que quieras que tu servidor se conecte con otros servidores
# de forma que tus usuarios tengan otros usuarios con quien chatear.
# Los servidores del IRC conectan con otros servidores formando una red
# con topología de estrella o árbol. No se permiten los bucles (Loops). 
# En esta red, dos servidores pueden ser distinguidos: servidores "hub"
# y "leaf". Los servidores "leaf" se conectan con los "hubs"; los "hub"
# se conectan entre ellos. Por supuesto, muchos servidores no se pueden
# clasificar directamente en una de esas categorias. Existe un sistema
# predefindo de toma de decisión basado en las reglas para los enlaces 
# de los servidores se proporciona para decidir a que enlaces permitr,
# cuales se dejan establecer a mano, y cuales de los enlaces denegar (a
# la fuerza).
#
# Los bloques "Connect"
# define con qué servidores conecta el servidores, y qué servidores se
# permiten conectar.
# Connect {
#  name = "nombreservidor";
#  host = "hostnameOip";
#  vhost = "IPlocal";
#  password = "contraseña";
#  port = númeropuerto;
#  class = "nombreclase";
#  maxhops = 2;
#  hub = "*.eu.irc-hispano.org";
#  autoconnect = no;
#  sslfp = "huelladigitalssl";
#  sslciphers = "cifrados ssl";
#  ssl = no;
# };
#
# El campo "port" define el puerto por defecto que el servidor intentará
# conectar si un operador utiliza el comando "/connect" sin especificar
# un puerto. Este también es el puerto usado para los intentos del servidor
# de autoconectar con el servidor remoto. (Véase los bloques "Class" para
# más informacion sobre "auto-connects").
# Puedes hacer que el ircd no se conecte automáticamente con un servidor
# ańadiendo "autoconnect = no"; por defecto está la autoconexión.
#
# Si el campo "vhost" está presente, el servidor utilizará esa IP como el
# final local de las conexiones que inicia a este servidor. Esto reemplaza
# el valor vhost del bloque General.
#
# Si el campo "sslfp" está presente, el servidor remoto debe estar conectado
# a través de SSL usando un certificado SSL con la huella digital SHA256
# especificada para se le permita usar el bloque "Connect".
#
# Si el campo "ssliphers" está presente, la lista de cifrados especificada
# se usará cuando este servidor se conecte al servidor del bloque "Connect"
# pertenece a. Consulte https://www.openssl.org/docs/apps/ciphers.html para
# obtener una explicación sobre cómo formatear esta cadena.
#
# El campo "maxhops" causa un SQUIT si un hub intenta introducir servidores
# más lejos que eso, el elemento "leaf"; es un alias para "maxhops = 0;".
# El campo "hub" limita los nombres de los servidores que pueden introducir
# por un hub, el elemento "hub;" es un alias para "hub = "*";".
#
# Nuestro uplink primario.
Connect {
 name = "hub.irc-hispano.org;
 host = "1.2.3.4";
 password = "passwd";
 port = 4400;
 class = "Servidor";
 hub;
};

# [Crule]
#
# Para un sistema avanzado de toma de decisiones basado en las reglas de
# encaminamiento en tiempo real puedes utilizar los bloques "Crule". Para
# más información, vea doc/readme.crules.es.
# Si hay más de una máscara de servidor en un solo bloque "Crule", la regla
# se aplica a todos los servidores.
# CRULE
# {
#  server = "servermask";
#  rule = "connectrule";

#  # Establecer "all" a "yes" hace que la regla siempre se aplique. De lo
#  # de lo contrario solo se aplica a autoconexiones.
#  all = yes;
# };
CRULE
{
 server = "*.US.IRC-Hispano.org";
 rule = "connected(*.US.IRC-Hispano.org)";
};
CRULE
{
 server = "*.EU.IRC-Hispano.org";
 rule = "connected(Vigo.ES.EU.*)";
};

# Se recomienda el siguiente bloque para servidores leaf:
CRULE
{
 server = "*";
 rule = "directcon(*)";
};

# [Operator]
#
# Inevitablemente, has alcanzado la parte sobre los Operadores del IRC (IRC
# Operators). El estado de Oper condece algunos privilegios especiales a un
# usuario, como la capacidad de poder desconectar el servidor de otro
# o (intentar a) establecer una conexión con otro usuario y a expulsar
# (kill) a usuarios del IRC.
# Se podrian escribir muchas páginas sobre esto; Resumamos con que si
# deseas designar a alguien como operador del IRC (IRC Operator) en tu
# servidor, esta persona debe estar enterado de sus responsabilidades, y
# eso, siendo el admin, el responsable de sus actos.
#
# Hay dos clases de Operadores del IRC (IRC Operators): "local" y "global".
# Los Opers locales pueden hacer "squit", "connect" y "kill" - pero
# solamente localmente: su modo de usuario de +o no se propaga a los otros
# servidores. En IRC-Dev, esto previene ellos de usar Uworld también.
#
# Más de un host = "máscara"; la entrada puede estar presente en un bloque;
# Esto tiene el mismo efecto que un bloque "Operador" para cada entrada de
# host, pero facilita la actualización de nicks, contraseñas, clases y
# privilegios de operador.
#
# En la mayoría de los casos, la máscara de host debe comenzar con "<ident>@"
# o "* @". Si no hay un prefijo <ident>@, los clientes sin resultados de
# ident (pero que coincidan con el nombre de host o la dirección IP) pueden
# utilizar el bloque Operator.
#
# Operator {
#  host = "máscara host/IP";
#  name = "nombreoper";
#  password = "contraseńacifrada";
#  class = "nombreclase";
#  sslfp = "huelladigitalssl";
#  # Puedes fijar también cualquier privilegio del operador; vea
#  # la documentación del bloque "Class" para más detalles. Un
#  # privilegio definido para un solo Operador prevalecerá los 
#  # ajustes de privilegios para la Clase y para el ajuste por
#  # defecto.
# };
#
# Por defecto, la contraseńa se encripta con la función nativa crypt()
# del sistema. Otros mecanismos de encriptación de contraseńa están
# disponibles; la utilidad del "umkpasswd" en el directorio del ircd
# permite encriptar contraseńas utilizando otros mecanismos (SMD5, etc...)
# Si usa un formato de contraseña que NO es generado por umkpasswd, irch
# no reconocerá la contraseña de operador.
#
# Si el campo "sslfp" está presente, el usuario debe estar conectado
# a traves de SSL desde un cliente configurado para usar un certificado
# de cliente SSL con la huella digital SHA256 especificada.

#
# Todos los privilegios son mostrados con los valores por defecto; Si
# deseas eliminar los valores por defecto, debes fijar solamente esos
# privilegios para el operador. Enumerar los privilegios omitidos apenas
# hace las cosas más duras para encontrar.
Operator {
 local = no;
 host = "*@*.rima-tde.net";
 password = "$CRYPT$KI88nphRm0UPw";
 name = "zoltan";
 class = "Local";
};
Operator {   
 host = "*@*.ttd.es";
 password = "$PLAIN$passnocifrada";
 name = "zolty";
 class = "Opers";
};

# Notese que el campo "class" es opcional, pero dejarla vacía pone los
# opers en la clase "default", que acepta generalmente una sola conexión
# a la vez. Si deseas que haya más de un usuario para Oper por bloque,
# entonces utiliza una clase de conexión que permita más de una conexión,
# por ejemplo (usando la clase "Local" como en el ejemplo de arriba):
#
# Una vez que te haces OPER tu clase de conexión cambia, no importa de
# dónde eres o tus clases de conexión anteriores. Si la clase de conexión
# definida es "Local" para el bloque "Operator", entonces tu nueva clase
# de conexión es "Local".

# [Port]
# Cuando tu servidor consigue llenarse, notarás retrasos al intentar
# conectar al puerto de escucha primario de tu servidor. Es posible con las
# lineas "Port" para especificar puertos adicionales para que el ircd los
# escuche. De hecho los puertos son: 6667 - estándar; 6660-6669 - puertos
# adicionales de clientes;
# Usar 4000 para puerto de escucha de servidores.
# Esto es sólo por convenio, no hay políticas oficiales de la IANA ni del
# IETF.
# La IANA dice que debemos usar el puerto 194, pero éste requiere que 
# el ircd funcione como root, así que no lo hacemos.
#
# Port {
#  port = [ipv4] [ipv6] número;
#  mask = "máscaraip";
#  # Utilice esto para controlar la interfaz para "bindear".
#  vhost = [ipv4] [ipv6] "ipvirtualhost";
#  # Puedes especificar el host virtual y el número de puerto en una entrada.
#  vhost = [ipv4] [ipv6] "ipvirtualhost" número;
#  # Ajustando a "yes" hace que sea de sólo servidores.
#  server = yes;
#  # Ajustando a "yes" hace que el port no salga en los "stats".
#  hidden = yes;
#  # Ajustando a "yes" hace que solo acepte clientes webirc.
#  # Si está activada la caracteristica head-in-sand (HIS) de webirc, es 
#  # probable que los puertos WebIRC también se oculten.
#  WebIRC = yes;
#  # Ajustando a "yes" hace que el puerto acepte conexiones SSL encriptadas.
#  ssl = yes;
#  # Ajustando a "yes" hace que el puerto esté exento de restricciones de
#  # conexión durante un /restart o /die programado.
#  exempt = yes;
# };

#
# Las líneas de "port" y "vhost" te permiten especificar uno o ambos de "ipv4"
# e "ipv6" como familias de direcciones para usar en el puerto. El valor
# predeterminado es escuchar tanto en IPv4 como en IPv6.
#
# El ajuste del campo "mask" permite que especifiques un rango de
# direcciones IP de las cuales permitirás conexiones. Esto debe contener
# solamente direcciones IP y '*' si está utilizada. Este campo utiliza
# solamente direcciones IP. Esto no utiliza resolución DNS de ninguna manera
# así que no puedes utilizarlo para permitir *.nl o *.uk. Los intentos de
# especificar cualquier cosa excepto números, puntos y estrella [0-9.*]
# dará lugar que en el puerto permitirá conexiones desde cualquier sitio.
#
# El ajuste de la interface permite a los servidores "multihosts" a
# especificar que interface será utilizada en el puerto, si una interfaz
# no está especificada, será utilizada la interfaz por defecto. La interfaz
# DEBE ser la dirección IP completa de la interfaz hardware real en la
# máquina donde corre el ircd.
# Si deseas utilizar "virtual hosting" *TU* *DEBES* *UTILIZAR* *ESTO*, de
# otra manera *SE USARA* todas las interfaces - que no es lo que espera la
# mayoría de la gente.
#
Port {
 server = yes;
 port = 4400;
};

# Este es un puerto SSL.
Port {
 ssl = yes;
 port = 6697;
};


# Este es un puerto de Servidor solamente IPv4 que está oculto
Port {
 server = yes;
 hidden = yes;
 port = ipv4 4401;
};

# Lo siguiente son puertos normales de cliente
Port { port = 6667; };
Port { port = 6668; };
Port {
 # Esto solo acepta clientes con rango de IP's 192.168.*.
 mask = "192.168.*";
 port = 6666;
 # Permite a los operadores conectar durante un /restart o /die programado.
 exempt = yes;  
};

# Esto es un puerto de cliente oculto, escuchando en 168.8.21.107.
Port {
 vhost = "168.8.21.107";
 hidden = yes;
 port = 7000;
};

# Más de un vhost puede estar presente en un único bloque Port; en este caso,
# recomendamos listar el número de puerto en la línea de vhost para mayor claridad.
Port {
 vhost = "172.16.0.1" 6667;
 vhost = "172.16.3.1" 6668;
 hidden = no;
};

# [Quarantine]
# Los bloques "Quarantine" prohiben a los operadores utiizar OPMODE y
# CLEARMODE en ciertos canales.  Los operadores con el privilegio
# force_opmode (para canales locales, force_local_opmode) pueden saltar
# la prohibición prefijando el nombre de canal con una exclamación ('!').
# Los comodines NO están soportados; el nombre del canal debe ser exacto.
Quarantine {
  "#shells" = "Thou shalt not support the h4><0rz";
  "&kiddies" = "They can take care of themselves";
};

# [Pseudo]
# Esto es un alias implementado del servidor para enviar un mensaje a un
# service. La cadena después de Pseudo es el nombre del comando; el campo
# "name" es el nombre del service, usado para los mensajes de error. Más
# de una entrada del campo "nick" puede ser proporcionadas, la última
# listada es la que tiene la prioridad más alta.
Pseudo "CHANSERV" {
 name = "X";
 nick = "X@channels.undernet.org";
};

# Puedes poner un texto "prepend" antes del mensaje del usuario.
Pseudo "LOGIN" {
 name = "X";
 prepend = "LOGIN ";
 nick = "X@channels.undernet.org";
};

# [IAuth]
# Puedes pedir a un servidor independiente si permite que los usuarios
# se conecten.
# Descomente esto SOLAMENTE si tiene un programa de ayuda de iauth.
# IAuth {
# Program = "../path/to/iauth" "-n" "opciones";
# };

# [WebIRC]
# Los clientes que se conectan a un puerto WebIRC, coinciden con un
# bloque WebIRC y envían
# "WEBIRC <contraseña> <nombre de usuario> <hostname> <ip>" durante
# el registro pueden "engañar" (spoof) su nombre de usuario,
# nombre de host y dirección IP.
#
# Una rehash desconectará a los clientes que usan un bloque de WebIRC que fue
# eliminado. Un bloque WebIRC se considera eliminado si no hay bloque en la
# nuevoa configuracion con la misma IP y contraseña - si sólo la descripción
# cambia, la nueva descripción se muestra en el /whois incluso para los
# clientes que estuvieron conectados antes del rehash.
WebIRC {
  ip = "1.2.3.4"; # Puede ser una máscara de red, p. 1.2.3.4/28
  password = "webirc-secreto";
  description = "algunos clientes webirc";
  hidden = yes; # oculta la IP en /stats webirc
};

# [Include]
# Puede incluir ciertos tipos de snippets de configuración de otros
# archivos. La directiva básica, que permite incluir cualquier tipo de
#  bloque o recursivo, es:
#
#   Include "nombre archivo";
#
# Puedes limitar el archivo a ciertos tipos de bloques de configuración
# utilizando el nombre de los bloques, opcionalmente separados por comas.
# Por ejemplo:
#
#   Include uworld, jupe, quarantine, kill from "linesync.conf";
#   Include operator from "opers.conf";
#   Include include from "include.conf";
#
# Las restricciones son transitivas a través de "includes". Esto
# significa que el último ejemplo no es muy útil: lo único que
# include.conf puede hacer es incluir otros archivos de inclusión,
# y ninguno de ellos puede tener otro tipo de bloque!
#
# Los bloques de configuración bien formados pero no permitidos generan
# una advertencia pero no rompen el archivo. Las otras reglas de sintaxis
# deben seguirse, ya que un error de sintaxis romperá el archivo.

# [Features]
# Los servidores de IRC tienen una gran cantidad de opciones y
# características. La mayoria de éstos se ajustan en tiempo de compilación
# con el uso de #define's  --ver "make config" para más detalles -- pero
# estamos trabajando para mover muchos de éstos al archivo de configuracion.
# Las características (features) permiten ajustarlos en tiempo real.
# Sólo necesitas un bloque "feature" en el cual se usa del siguiente modo.
# "nombrecaracterstica" = "valor1" , "valor2", ..., "valorn-1", "valorn";
#
# El propósito entero de las F:lines es que no tengas que recompilar el IRCD
# cada vez que quieres cambiar una característica (feature). Todas las
# características se enumeran abajo, y al final cómo ajustar el "logging".
#
# Gracias especiales a Kev por escribir la documentación de F:lines. Eso
# puede ser encontrado en doc/es/features.txt y la documentación de registro
# de eventos (logging) se puede encontrar en doc/es/log.txt. Los valores por
# defecto usados por la red de IRC-Dev están abajo.
#
Features
{
# Estas características de registro de eventos (logging) son la única
# manera de conseguir ciertos mensajes de error (por ejemplo cuando el
# servidor se muere de sin memoria.) Para más explicación de como se
# usa, vea doc/es/log.txt
 "LOG" = "SYSTEM" "FILE" "ircd.log";
 "LOG" = "SYSTEM" "LEVEL" "CRIT";
#  "DOMAINNAME" = "<obtenido desde /etc/resolv.conf por el ./configure>";
#  "RELIABLE_CLOCK"="FALSE";
#  "BUFFERPOOL"="27000000";
#  "HAS_FERGUSON_FLUSHER"="FALSE";
#  "CLIENT_FLOOD"="2048";
#  "SERVER_PORT"="4400";
#  "NODEFAULTMOTD"="TRUE";
#  "MOTD_BANNER"="texto";
#  "PROVIDER" ="texto";
#  "KILL_IPMISMATCH"="FALSE";
#  "IDLE_FROM_MSG"="TRUE";
#  "HUB"="FALSE";
#  "WALLOPS_OPER_ONLY"="FALSE";
#  "NODNS"="FALSE";
#  "NOIDENT"="FALSE";
#  "RANDOM_SEED"="<you should set one explicitly>";
#  "DEFAULT_LIST_PARAM"="TRUE";
#  "NICKNAMEHISTORYLENGTH"="800";
#  "NETWORK"="IRC-Hispano";
#  "HOST_HIDING"="FALSE";
#  "HIDDEN_HOST"="users.irc-hispano.org";
#  "HIDDEN_IP"="127.0.0.1";
#  "KILLCHASETIMELIMIT"="30";
#  "MAXCHANNELSPERUSER"="10";
#  "NICKLEN" = "12";
#  "AVBANLEN"="40";
#  "MAXBANS"="30";
#  "MAXSILES"="15";
#  "MAXMONITOR"="100";
#  "HANGONGOODLINK"="300";
#  "HANGONRETRYDELAY" = "10";
#  "CONNECTTIMEOUT" = "90";
#  "MAXIMUM_LINKS" = "1";
#  "PINGFREQUENCY" = "120";
#  "CONNECTFREQUENCY" = "600";
#  "DEFAULTMAXSENDQLENGTH" = "40000";
#  "GLINEMAXUSERCOUNT" = "20";
#  "MPATH" = "ircd.motd";
#  "RPATH" = "remote.motd";
#  "PPATH" = "ircd.pid";
#  "TOS_SERVER" = "0x08";
#  "TOS_CLIENT" = "0x08";
#  "POLLS_PER_LOOP" = "200";
#  "IRCD_RES_TIMEOUT" = "4";
#  "IRCD_RES_RETRIES" = "2";
#  "AUTH_TIMEOUT" = "9";
#  "IPCHECK_CLONE_LIMIT" = "4";
#  "IPCHECK_CLONE_PERIOD" = "40";
#  "IPCHECK_CLONE_DELAY" = "600";
#  "CHANNELLEN" = "200";
#  "CONFIG_OPERCMDS" = "FALSE";
#  "OPLEVELS" = "TRUE";
#  "ZANNELS" = "TRUE";
#  "LOCAL_CHANNELS" = "TRUE";
#  "ANNOUNCE_INVITES" = "FALSE";
#  "HIS_SNOTICES" = "TRUE";
#  "HIS_SNOTICES_OPER_ONLY" = "TRUE";
#  "HIS_DEBUG_OPER_ONLY" = "TRUE";
#  "HIS_WALLOPS" = "TRUE";
#  "HIS_MAP" = "FALSE";
#  "HIS_LINKS" = "FALSE";
#  "HIS_TRACE" = "TRUE";
#  "HIS_STATS_a" = "TRUE";
#  "HIS_STATS_c" = "TRUE";
#  "HIS_STATS_d" = "TRUE";
#  "HIS_STATS_e" = "TRUE";
#  "HIS_STATS_E" = "TRUE";
#  "HIS_STATS_f" = "TRUE";
#  "HIS_STATS_g" = "TRUE";
#  "HIS_STATS_i" = "TRUE";
#  "HIS_STATS_j" = "TRUE";
#  "HIS_STATS_J" = "TRUE";
#  "HIS_STATS_k" = "TRUE";
#  "HIS_STATS_l" = "TRUE";
#  "HIS_STATS_L" = "TRUE";
#  "HIS_STATS_m" = "TRUE";
#  "HIS_STATS_M" = "TRUE";
#  "HIS_STATS_o" = "TRUE";
#  "HIS_STATS_p" = "TRUE";
#  "HIS_STATS_q" = "TRUE";
#  "HIS_STATS_r" = "TRUE";
#  "HIS_STATS_R" = "TRUE";
#  "HIS_STATS_t" = "TRUE";
#  "HIS_STATS_T" = "TRUE";
#  "HIS_STATS_u" = "FALSE";
#  "HIS_STATS_U" = "TRUE";
#  "HIS_STATS_v" = "TRUE";
#  "HIS_STATS_w" = "TRUE";
#  "HIS_STATS_W" = "TRUE";
#  "HIS_STATS_x" = "TRUE";
#  "HIS_STATS_y" = "TRUE";
#  "HIS_STATS_z" = "TRUE";
#  "HIS_STATS_IAUTH" = "TRUE";
#  "HIS_WEBIRC" = "TRUE";
#  "HIS_WHOIS_SERVERNAME" = "TRUE";
#  "HIS_WHOIS_IDLETIME" = "TRUE";
#  "HIS_WHOIS_LOCALCHAN" = "TRUE";
#  "HIS_WHO_SERVERNAME" = "TRUE";
#  "HIS_WHO_HOPCOUNT" = "TRUE";
#  "HIS_MODEWHO" = "TRUE";
#  "HIS_BANWHO" = "TRUE";
#  "HIS_KILLWHO" = "TRUE";
#  "HIS_REWRITE" = "TRUE";
#  "HIS_REMOTE" = "TRUE";
#  "HIS_NETSPLIT" = "TRUE";
#  "HIS_SERVERS" = "TRUE";
#  "HIS_SERVERNAME" = "*.irc-hispano.org";
#  "HIS_SERVERINFO" = "IRC-Hispano, la red Hispana";
#  "HIS_URLSERVERS" = "https://www.irc-hispano.org/servidores";
#  "URLREG" = "https://www.irc-hispano.org/regnick";
#  "ALLOW_RANDOM_NICKS" = "TRUE";
#  "PREFIX_RANDOM_NICKS" = "Guest-";
#  "ALLOW_SUSPEND_NICKS" = "TRUE";
#  "UHNAMES" = "TRUE";
#  "SSL_CERTFILE" = "ircd.pem";
#  "SSL_KEYFILE" = "ircd.pem";
#  "SSL_CACERTFILE" = "";
#  "SSL_VERIFYCERT" = "FALSE";
#  "SSL_NOSELFSIGNED" = "FALSE";
#  "SSL_REQUIRECLIENTCERT" = "FALSE";
#  "SSL_NOSSLV2" = "TRUE";
#  "SSL_NOSSLv3" = "TRUE";
#  "SSL_NOTLSV1" = "TRUE";
#  "SSL_CIPHERS" = "";
#  "CAP_multi_prefix" = "TRUE";
#  "CAP_userhost_in_names" = "TRUE";
#  "CAP_extended_join" = "TRUE";
#  "CAP_away_notify" = "TRUE";
#  "CAP_account_notify" = "TRUE";
#  "CAP_invite_notify" = "TRUE";
#  "CAP_sasl" = "TRUE";
#  "CAP_tls" = "TRUE";
};

# Bien, has llegado al final de este ejemplo del archivo de configuración.
# Si tienes alguna pregunta, visita http://www.irc-hispano.org o entra en el
# canal #irch de IRC-Hispano y nos las planteas :-)
#
# Las actualizaciones de este ircd se puede encontrar via Git o por
# descarga directa en https://gitlab.com/IRCHispano/IRCh
#
# Buena suerte con el resto!
